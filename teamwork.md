<h1> Teamwork for Iteration 3: DishDANG </h1>

<h2>Introduction</h2>

<p>For iteration 3, our team primarily focused on finishing the foundations that we had built in the previous iteration, which involved cleaning our code, making sure our frontend worked efficiently with our backend, as well as finalising the tests for each function created. We were also required to adapt to customer feedback listed in the repository, which included adding new functions such as list_all, and returning extra information in functions such as the url to the profile images in the user function. This lead our team to continue using agile approaches in order to complete the tasks set in a much more efficient and effective way.</p>

<h2>Meetings</h2>

We had one meeting before our tute in weeks 7, 8, and 9 to discuss any technical issues which we could resolve together, and if it was not successful, using the tutorial/lab after was perfect timing. We planned these meetings when Iteration 3 was released and confirmed a timeslot where everyone was available. To ensure the meeting ran successfully, we used an agenda and did our work before the meeting so that our time together would be maximised and efficient. In addition, we utilised rooms at uni where there was a large TV screen so that we could use a HDMI cable to ensure everyone was following and that everyone could work on the same issues at the same time.

<h2>Dealing with Conflict</h2>

Although we had some issues for Iteration 2, we decided to allocate the work earlier and set deadlines throught the weeks leading up. This was so that we could break down the task and ensure that other team members could help out someone struggling. This kept us on track and was an extremely useful method. When things did not go to plan, we would have a call over messenger and use Piazza forums to look for answers. Since multiple people were working on the same code, we ensured we used good Gitlab practices such as pulling often and using commits which describe what we did to update the code (pair programming was very useful as we could see live what was being changed and why they needed to change). When there were specific merge conflicts where we didn't know why they changed the code, we would first look at the commits and see what they changed, and if it still did not make sense we would message the group chat to discuss with the entire team.

<h2>Allocations</h2>

<p>We allocated equivalent amounts of code to each team member, as well as thorough parts of documentation. This made our task much easier as each individual knew what part they had to contribute to, and how long it would take. This, going in hand with time limits, allowed us to track our constant progress, and if we ever ran into any queries, every member was upto date with the project, enough for each person to be able to help with the problem, in turn making the project even easier. Below, is an allocation spreadsheet that we have kept track of since iteration 1.</p>

![Allocations](/uploads/62f105abfc770e87e9638ebe3a2c27bf/Allocations.png)

<h2>Agile Approaches</h2>

<h3>Pair Programming</h3>

<p>Our primary path of finishing all of our tests and functions in a much quicker way was to use pair programming. Our team would often sit down in pairs over the course of the two weeks, and work on the test functions that we had incorporated. We had split our functions in such a way that one member wrote the function, and another member wrote the test for it, e.g. Didier wrote standup.py and Hoshang wrote standup_start_test.py. Through this, the pair would then sit down and send code back and forth, until all tests have been covered and the function is not only efficient, but also successful with running in the frontend.</p>

<h3>Standups</h3>

<p>With a combination of asynchronous and synchronous standups, our team decided to meet up atleast once a week before our tutorials, in order to get a head start on the content we learnt for the next week. In these meetings, we would individually give a two-minute summary of what we had done for that week, and how our part of the iteration was going. These meetings were very productive, and we were easily able to keep track of how much progress we had made for this iteration.</p>

<h2>Conclusion</h2>

<p>With our final iteration done, we had successfully written, tested and linked our functions to the frontend. We also refined and simplified our code to make it legible, and much more efficient. The team was also able to constantly update our documentation and we were able to complete our tasks, including our Diagrams and Principles in perfect time. Thus, with each team member contributing evenly, we had a successful iteration and hence, a successful project.</p>